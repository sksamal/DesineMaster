/******************************************************************************

    source file TopologyFactory.cpp for class: TopologyFactory

    See header file for details

    Author : T. Kleiberg
    Version: 1
    Date   : Sep 2006

    Feb8,2016 : Suraj merged changes
******************************************************************************/


// Include(s)
#include "Network/TopologyFactory.h"
#include "IO/FileReader.h"
#include "IO/Tag.h"
#include "IO/cJSON.h"
#include "Utils/TraceManager.h"
#include <deque>
#include <set>
#include <string>
#include <cmath>
using std::deque;
using std::string;
using Types::uli;
using Types::DblVector;

// Implementations of Topology generators
#include "Network/TopologyFactoryAdjacency.cpp"
#include "Network/TopologyFactoryBarabasi.cpp"
#include "Network/TopologyFactoryErdos.cpp"
#include "Network/TopologyFactoryFile.cpp"
#include "Network/TopologyFactoryFull.cpp"
#include "Network/TopologyFactoryGrid.cpp"
#include "Network/TopologyFactoryRandom.cpp"
#include "Network/TopologyFactoryFatTree.cpp"
#include "Network/TopologyFactorySlimNet.h"
#include "Network/TopologyFactorySlimNet.cpp"
#include "Network/TopologyFactoryCell.cpp"


// Constanst(s)
const double TopologyFactory::default_capacity = 1.0;

// Variable(s)

// Function(s) definitions

//------------------------------------------------------------------------------
//  constructor TopologyFactory::TopologyFactory()
//------------------------------------------------------------------------------
TopologyFactory::TopologyFactory(RandomVar* link_capacity,RandomVar* hlink_capacity) :
    link_capacity(link_capacity),hlink_capacity(hlink_capacity)
{
  	TRACE("TopologyFactory::TopologyFactory -->");
    rng = RandomNumberGenerator::getRandomNumberGenerator();
  	TRACE("TopologyFactory::TopologyFactory <--");
}


//------------------------------------------------------------------------------
//  destructor TopologyFactory::~TopologyFactory()
//------------------------------------------------------------------------------
TopologyFactory::~TopologyFactory()
{
	TRACE("TopologyFactory::~TopologyFactory -->");
    //Empty
	TRACE("TopologyFactory::~TopologyFactory <--");
}


//------------------------------------------------------------------------------
//  Topology* create();
//------------------------------------------------------------------------------
Topology* TopologyFactory::create(const TString &description)
{
	TRACE("TopologyFactory::create -->");
    //description.print(*TraceManager::getStream());
    //TRACE(' ');

    Topology* result = (Topology*) 0;
    if (description.front() == Tag::TOP_ADJACENCY)
    {
        result = createTopologyAdjacency(description);
    } else
    if (description.front() == Tag::TOP_BARABASI)
    {
        result = createTopologyBarabasi(description);
    } else
    if (description.front() == Tag::TOP_ERDOS)
    {
        result = createTopologyErdos(description);
    } else
    if (description.front() == Tag::TOP_FILE)
    {
        result = createTopologyFile(description);
    } else
    if (description.front() == Tag::TOP_FULL)
    {
        result = createTopologyFull(description);
    } else
    if (description.front() == Tag::TOP_GRID2D)
    {
        result = createTopologyGrid2D(description);
    } else
    if (description.front() == Tag::TOP_RANDOM)
    {
        result = createTopologyRandom(description);
    } else
    if (description.front() == Tag::TOP_FATTREE)
    {
	result = createTopologyFatTree(description);
    } else
    if (description.front() == Tag::TOP_SLIMNET)
    {
	result = createTopologySlimNet(description);
    } else
    if (description.front() == Tag::TOP_CELL)
    {
	result = createTopologyCell(description);
    }
    else
    {
        // No matching topology could be found....
        ERROR("Unknown description: " << description.front());
        exit(-1);
    }

	TRACE("TopologyFactory::create <--");
    return result;
}

//------------------------------------------------------------------------------
//  void build(const NodePairDeque &nodepairs, Topology* topology)
//------------------------------------------------------------------------------
void TopologyFactory::build(const NodePairDeque &nodepairs, Topology* topology)
{
    TRACE("TopologyFactory::build -->");
    for(NodePairDeque::const_iterator iter = nodepairs.begin();
        iter != nodepairs.end(); ++iter)
    {
		if (iter->source != iter->destination)
		{
	        double link_cap = link_capacity == (RandomVar*) 0 ?
	            default_capacity : link_capacity->generate();
	        double hlink_cap = hlink_capacity == (RandomVar*) 0 ?
	            default_capacity : hlink_capacity->generate();
	        DblVector d;
	        d.push_back(iter->source);             // source
	        d.push_back(iter->destination);        // dest
	        d.push_back(0.0);                      // core
	        d.push_back(link_cap); // cap
	        topology->link_list->insert(d);
//		cout<<iter->source<<"--"<<iter->destination<<"connected"<<endl;
	        if (!topology->is_directed)
	        {
	            DblVector d2;
	            d2.push_back(iter->destination);  // source
	            d2.push_back(iter->source);       // dest
	            d2.push_back(0.0);                // core
		    if(iter->isHost)
			d2.push_back(hlink_cap);
		    else
	            	d2.push_back(link_cap); // cap
	            topology->link_list->insert(d2);
//		    cout<<iter->destination<<"--"<<iter->source<<"connected"<<endl;
	        } //end: if (!topology->is_directed)
		} //end: if (iter->source != iter->destination)
    }
    TRACE("TopologyFactory::build <--");
}

//------------------------------------------------------------------------------
//  void export(const NodePairDeque &nodepairs, Topology* topology)
//------------------------------------------------------------------------------
void TopologyFactory::exportJSON(const NodePairDeque &nodepairs, Topology* topology)
{
    TRACE("TopologyFactory::exportJSON -->");
    cJSON *root,*fmt;char *out;	/* declare a few. */
	/* Our "days of the week" array: */
	const char *strings[7]={"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};

	const char *nodes[topology->number_of_nodes];
	root=cJSON_CreateObject();	
	cJSON_AddItemToObject(root, "comment", cJSON_CreateString("Suraj"));
 	for(int i=0;i<topology->number_of_nodes;i++) {
	   cJSON *temp = cJSON_CreateObject();
	   cJSON_AddNumberToObject(temp,"id",i);
	   char *caption = new char[10];
	   sprintf(caption,"Node-%d",i); 
	   cJSON_AddStringToObject(temp,"caption",caption);
	   cJSON_AddItemToArray(root,temp);
	}	
	fmt=cJSON_CreateStringArray(nodes,topology->number_of_nodes);
	//cJSON_AddItemToObject(root, "nodes", fmt=cJSON_CreateObject());
	cJSON_AddItemToObject(root, "nodes",fmt);
	cJSON_AddStringToObject(fmt,"type",		"rect");
	cJSON_AddNumberToObject(fmt,"width",		1920);
	cJSON_AddNumberToObject(fmt,"height",		1080);
	cJSON_AddFalseToObject (fmt,"interlace");
	cJSON_AddNumberToObject(fmt,"frame rate",	24);
	
	out=cJSON_Print(root);	cJSON_Delete(root);	printf("%s\n",out);	free(out);	/* Print to text, Delete the cJSON, print it, release the string. */

	/* Our "days of the week" array: */
	root=cJSON_CreateStringArray(strings,7);
	out=cJSON_Print(root);	cJSON_Delete(root);	printf("%s\n",out);	free(out);

/*
    for(NodePairDeque::const_iterator iter = nodepairs.begin();
        iter != nodepairs.end(); ++iter)
    {
		if (iter->source != iter->destination)
		{
	        double link_cap = link_capacity == (RandomVar*) 0 ?
	            default_capacity : link_capacity->generate();
	        double hlink_cap = hlink_capacity == (RandomVar*) 0 ?
	            default_capacity : hlink_capacity->generate();
	        DblVector d;
	        d.push_back(iter->source);             // source
	        d.push_back(iter->destination);        // dest
	        d.push_back(0.0);                      // core
	        d.push_back(link_cap); // cap
	        topology->link_list->insert(d);
	        if (!topology->is_directed)
	        {
	            DblVector d2;
	            d2.push_back(iter->destination);  // source
	            d2.push_back(iter->source);       // dest
	            d2.push_back(0.0);                // core
		    if(iter->isHost)
			d2.push_back(hlink_cap);
		    else
	            	d2.push_back(link_cap); // cap
	            topology->link_list->insert(d2);
	        } //end: if (!topology->is_directed)
		} //end: if (iter->source != iter->destination)
    } */
    TRACE("TopologyFactory::exportJSON <--");
}
